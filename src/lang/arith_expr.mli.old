open Core_kernel
open Lib.State.Cps

type op =
  | Plus
  | Minus
  | Mult
  | Div
[@@deriving compare, sexp, hash]

module Pattern : sig
  type 'a t =
    | Lit of int
    | Var of string
    | Binop of 'a * op * 'a

  include Lib.Pattern_functor.S with type 'a t := 'a t

  val lit : int -> 'a t
  val var : string -> 'a t
  val plus : 'a -> 'a -> 'a t
  val minus : 'a -> 'a -> 'a t
  val mult : 'a -> 'a -> 'a t
  val div : 'a -> 'a -> 'a t
end 

module Fixed : Lib.Fix.S with module Pattern := Pattern

include Lib.Fix.S with module Pattern := Pattern

val lit : 'a -> int -> 'a t
val lit_ : int -> unit t
val var  : 'a -> string -> 'a t
val var_ : string -> unit t
val plus : 'a -> 'a t -> 'a t -> 'a t 
val plus_ : unit t -> unit t -> unit t 
val minus : 'a -> 'a t -> 'a t -> 'a t 
val minus_ : unit t -> unit t -> unit t 
val mult : 'a -> 'a t -> 'a t -> 'a t 
val mult_ : unit t -> unit t -> unit t 
val div : 'a -> 'a t -> 'a t -> 'a t 
val div_ : unit t -> unit t -> unit t 

module Make_traversable(M: Monad.S) : Lib.Traversable.S with module M := M and module F := Fixed

module Make_traversable2(M: Monad.S2) : Lib.Traversable.S2 with module M := M and module F := Fixed

module Traversable_state : Lib.Traversable.S2 with module M := State and module F := Fixed

val traverse_state : f:('a -> ('b,'e) State.t) -> 'a t -> ('b t, 'e) State.t

module Unlabelled : sig
    type meta = unit 
    type nonrec t = meta t
    include Sexpable.S with type t := t
    include Comparator.S with type t := t 
    val hash_fold_t : Hash.state ->  t -> Hash.state
    val unlabel : 'a Fixed.t -> t
end

module Labelled : sig
    module Label : Lib.Label.S with type t = int
    type meta = { label : Label.t [@compare.ignore] }
    type nonrec t = meta t
    include Sexpable.S with type t := t    
    include Comparator.S with type t := t
    val hash_fold_t : Hash.state ->  t -> Hash.state
    val label : 'a Fixed.t -> t
    val label_of : t -> Label.t
end
